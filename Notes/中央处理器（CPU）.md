微体系架构

# 1、ALU和RAM组成CPU

算术逻辑单元（ALU）, *输入二进制，它会执行计算。

我们还做了两种内存：**寄存器**，**很小的一块内存**，能存**一个值**。

之后我们**增大**做出了**RAM**，RAM是**一大块内存**，能在**不同地址存大量数字**。

将前两节构建的**ALU和RAM组合在一起**，就能组建计算机的心脏——**中央处理单元（Central Processing Unit，CPU）**。

# 2、CPU执行程序

**CPU**负责**执行程序**，而**程序由一个个操作组成**，这些**操作**称为**指令（Instruction）**，用来指示计算机**要做什么**。

如果是**数学指令**，比如**加减**，CPU就会**让ALU**进行**数学运算**；

如果是**内存指令**，CPU就会**和内存通信**，然后**读写值**。

## 2.1、构建CPU

想要**构建一个CPU：**

① 首先，我们**需要一些内存**，直接**使用上集构建的RAM**，简单来看，假设这个**RAM只有16个位置**，每个位置**保存一个字节**。

② 然后，我们需要**4个8位寄存器**，称为A、B、C和D，用来**临时存储** 数据和操作数据。

![[Pasted image 20250901162519.jpg]]

我们知道**数据是以二进制形式 保存在内存中**，其实程序也可以保存在内存中（因为**程序是由指令构成的**，所以其实就是将**程序的指令保存在内存中**）。

我们可以给CPU**支持的所有指令 分配一个ID**，可以得到**指令表（Instruction Table）**

![[Pasted image 20250901160756.png]]

在这个例子中：

我们使用**前四位**保存**操作码（Operation Code）**。

**后四位**表示数据从哪里来，可以是**寄存器或内存地址。**

③ 最后，**还需要**两个额外的寄存器来**完成CPU：**

一个**寄存器来追踪程序运行到了哪里**，称为[[指令地址寄存器]]（Instruction Address Register），用来**存放当前指令的内存地址**。

另一个**寄存器存放当前指令**，称为[[指令寄存器]]（Instruction Register）。

## 2.2、取指令阶段

假设我们**已经将一段程序保存在RAM当中了**，接下来会梳理一遍**CPU是如何执行这个程序**的。

CPU的第一个阶段叫**取指令阶段（Fetch Phase）**，负责**拿到指令**。

![[Pasted image 20250901162633.jpg]]

首先，将**指令地址寄存器**连接到RAM，

由于当我们**启动计算机时**，所有寄存器**从0开始**，

所以**指令地址**寄存器( 一个寄存器来追踪程序运行到了哪里)中的值为0，

将指令地址寄存器**与RAM的地址线相连**，

然后**开启RAM的允许读取线**，

就能使得**RAM获得** 地址0中保存的**值**，并且将RAM的数据线和**指令寄存器**(一个寄存器存放当前指令)相连，就能将**存放到指令寄存器**中。

![[Pasted image 20250901162647.jpg]]

## 2.3、解码阶段

取到指令后，CPU就会进入**解码阶段（Decode Phase）** 来**分析取到的指令内容**。

在这个例子中，**指令寄存器中保存的是00101110**。

前四位0010为**操作码**，通过**指令表**可知这个指令是**LOAD A指令**，就是**将RAM中的值保存在寄存器A中。**

而后四位1110**保存的是RAM地址**，转成十进制就是14。

所以指令00101110的意思就是将RAM中**第14位的数据(一共16个)** 保存到寄存器A中。

## 2.3.1、解码阶段控制单元

以上的解码过程，是由**控制单元（Control Unit）** 进行**解码**，控制单元也是由**逻辑门组成的**。比如**控制单元**要**检查操作码是否为LOAD A**，就需要以下电路，如果**返回1**，说明**操作码就是LOAD A**（所以对于指令表中的操作码，都需要对应的**电路进行判断**）。

![[Pasted image 20250901163314.png]]
## 2.4、执行阶段

现在**知道了**指令寄存器中**保存的指令后**，就进入了**执行阶段（Execute Phase）**。

通过**LOAD A指令的电路**，我们可以用来**控制RAM的允许读取线**。

比如LOAD A指令的**电路返回1**，则**说明要读取RAM**，所以**用这个1设置RAM的允许读取线来读取RAM的内容**；

如果LOAD A指令的**电路返回0**，说明**不需要读取RAM**，就**用这个0设置RAM的允许读取线来关闭RAM的读取**。

然后还需要将**指令中保存的地址(后四位)** 传到 **RAM的地址线**。

用“检查是否LOAD A指令的电路”**可以打开RAM**的“允许读取线”(LOAD A指令的**一部分**是要**打开“允许读取RAM”**)，**把地址14传过去**，RAM拿到值地址14的值0000 0011，十进制的3(**地址14只是RAM的一部分**，RAM拿到地址14的值，然后**RAM发送出来**)。

因为是LOAD A指令，我们想把这个值**只放到寄存器A**，其他寄存器**不受影响**。

所以**需要一根线**，把RAM**连到4个寄存器**。

用“**检查是否LOAD A指令的电路”启用寄存器A的“允许写入线”**，这样就把**RAM地址14的值放到寄存器A中**了。

![[Pasted image 20250901162736.png]]

## 2.5、下一条指令

**指令完成后**，就会**关闭所有线路**，然后再去**取下一条指令**，为此我们需要将**指令地址寄存器+1**，就能**结束执行阶段**，然后**重复执行以上步骤**。

## 2.6、控制单元抽象为一个整体

不同指令由**不同逻辑电路解码**，然后这些**逻辑电路**会**配置CPU中的组件**（比如开启关闭RAM的允许读写线，开启关闭对应寄存器的允许读写线等等）来**执行对应的操作**。

我们**不具体分析不同指令的控制单元**，可以直接将**控制单元抽象为一个整体**，其中包含**指令地址寄存器和指令寄存器**，然后会和**RAM的允许读取线、允许写入线、地址线和数据线相连**，并且还会**和四个寄存器相连**。

![[Pasted image 20250901162746.png]]

# 3、时钟

负责管理CPU的节奏

以精确的间隔触发电信号，控制单元使用该信号推进CPU的内部操作

## 3.1、时钟速度

CPU“取指令→解码→执行”的速度

单位：赫兹

---
第一个单芯片CPU：英特尔 4004

1971年发布的4位CPU

时钟速度：740kHz

---
## 1、CPU构成

## 1.1 控制单元

### 1.1.1、组成

1. [[指令寄存器]]（Instruction Register，IR）：用于存储当前正在执行的指令。
2. [[指令译码器]]（Instruction Decoder）：解释指令的含义，以便CPU能够理解并执行它们。
3. [[操作控制器]]（Operation Controller）：按照确定的时序，向相应的部件发出控制信号。

### 1.1.2、作用

1. **指令解码**：控制单元将从内存中读取的指令进行解码，以确定应该执行的操作。
2. **分支控制**：控制单元确定程序执行的流程，根据条件判断执行不同的指令路径，例如if-else语句或循环。
3. **控制时序**：控制单元确保指令按照正确的顺序执行，并协调各个部件之间的操作。

  

## 1.2 运算单元

### 1.2.1、[[算术逻辑单元]]（ALU）

算术逻辑单元是运算单元的核心部分，它负责执行各种算术运算（如加、减、乘、除）和逻辑运算（如与、或、非）。这些运算是计算机执行程序的基础，算术逻辑单元的高效运算能力对于计算机的性能至关重要。

### 1.2.2、[[累加寄存器]]

累加寄存器主要为CPU的运算提供一个工作区。在算术运算中，例如减法运算，它首先会存放被减数，然后将运算结果送回累加寄存器。累加寄存器在连续运算和复杂运算中起到了临时存储中间结果的作用。

### 1.2.3、[[数据缓冲寄存器]]

数据缓冲寄存器主要作为CPU、主存和外围设备之间数据传送的一个中转站及操作速度上的缓冲。在单累加器结构的运算器中，它还可以兼做操作数寄存器。这有助于确保数据在传输过程中的准确性和速度。

### 1.2.4、[[状态条件寄存器]]

状态条件寄存器保存算术指令和逻辑指令运算结果所建立的各种特征条件。它主要包含状态标志和控制标志，用于反映运算结果的状态，如溢出、零结果等，以及控制后续指令的执行。

## 1.3 存储单元

### 1.3.1、CPU片内缓存（Cache）

**组成**：Cache位于内存和CPU之间，是一个高速的存储区域。

**作用**：当CPU需要读取数据时，它首先会在Cache中查找。如果所需数据已经在Cache中（即Cache命中），CPU可以迅速获取这些数据，从而大大提高数据访问速度。如果Cache中没有所需数据（即Cache未命中），CPU则会通过总线从内存中读取数据，并将这些数据以及相邻的数据块加载到Cache中，以便后续的快速访问。这种机制显著减少了CPU直接访问内存的次数，从而提高了整体性能。

  

### 1.3.1.1、CPU三级缓存架构

现代CPU为了提升执行效率，减少CPU与内存的交互(交互影响CPU效率)，一般在CPU上集成了多级缓存架构，常见的为三级缓存结构。

- [[L1 Cache]]，分为数据缓存和指令缓存，逻辑核独占。
- [[L2 Cache]]，物理核独占，逻辑核共享。
- [[L3 Cache]]，所有物理核共享。

存储器存储空间大小：内存>L3>L2>L1>寄存器；

存储器速度快慢排序：寄存器>L1>L2>L3>内存；

![[Pasted image 20250901161531.jpg]]

### 1.3.1.2、CPU读取存储器数据过程-先进后远

1、CPU要取寄存器X的值，只需要一步：直接读取。

2、CPU要取L1 cache的某个值，需要1-3步（或者更多）：把cache行锁住，把某个数据拿来，解锁，如果没锁住就慢了。

3、CPU要取L2 cache的某个值，先要到L1 cache里取，L1当中不存在，在L2里，L2开始加锁，加锁以后，把L2里的数据复制到L1，再执行读L1的过程，上面的3步，再解锁。

4、CPU取L3 cache的也是一样，只不过先由L3复制到L2，从L2复制到L1，从L1到CPU。

5、CPU取内存则最复杂：通知内存控制器占用总线带宽，通知内存加锁，发起内存读请求，等待回应，回应数据保存到L3（如果没有就到L2），再从L3/2到L1，再从L1到CPU，之后解除总线锁定。

  

### 1.3.1.3、CPU为何要有高速缓存

CPU在**摩尔定律**的指导下以每18个月翻一番的速度在发展，然而内存和硬盘的发展速度远远不及CPU。这就造成了高性能能的内存和硬盘价格及其昂贵。然而CPU的高度运算需要高速的数据。为了解决这个问题，CPU厂商在CPU中内置了少量的高速缓存以**解决I\O速度和CPU运算速度之间的不匹配问题**。

  

### 1.3.2、寄存器组

**组成**：寄存器组包括**专用寄存器**和**通用寄存器**。

1. 专用寄存器的作用固定，用于寄存特定的数据；
2. 通用寄存器则用途广泛，可以由程序员根据需要进行配置。

**作用**：寄存器的主要作用是暂时存储CPU中的数据和指令。由于访问寄存器的速度远快于访问内存，因此使用寄存器可以显著减少CPU访问内存的次数，从而提高CPU的工作速度。然而，由于芯片面积和集成度的限制，寄存器组的容量相对较小。

## 2、工作原理

![[Pasted image 20250901161556.jpg]]

几乎所有的[[冯·诺伊曼型计算机]]的CPU，其工作都可以分为5个阶段：取指令、指令译码、执行指令、访存取数、结果写回。

- **取指令阶段**：是将内存中的指令读取到 CPU 中寄存器的过程，程序寄存器用于存储下一条指令所在的地址。
- **指令译码阶段**：在取指令完成后，立马进入指令译码阶段，在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。
- **执行指令阶段**：译码完成后，就需要执行这一条指令了，此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。
- **访问取数阶段**：根据指令的需要，有可能需要从内存中提取数据，此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。
- **结果写回阶段**：作为最后一个阶段，结果写回（Write Back，WB）阶段把执行指令阶段的运行结果数据“写回”到某种存储形式：结果数据经常被写到CPU的内部寄存器中，以便被后续的指令快速地存取。