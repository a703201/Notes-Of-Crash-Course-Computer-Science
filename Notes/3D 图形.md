2D的电脑屏幕上不可能有 XYZ 立体坐标轴，所以有图形算法负责把3D坐标"拍平"显示到2D屏幕上，这叫[[3D投影]]。所有的点都从3D转成2D后，就可以用画2D线段的函数来连接这些点，这叫 [[线框渲染]]

想象用筷子做一个立方体，然后用手电筒照它，墙上的影子就是投射，是平的。如果旋转立方体，投影看起来会像 3D 物体，尽管是投影面是平的。

![[Pasted image 20250919124903.jpg]]

电脑也是这样3D转2D，只不过用大量数学，而不是筷子，3D投影有好几种，你现在看到的，叫[[正交投影]]

立方体的各个边，在投影中互相平行，在真实3D世界中，平行线段会在远处收敛于一点，就像远处的马路汇聚到一点，这叫[[透视投射]]

![[Pasted image 20250919124911.jpg]]

过程是类似的，只是数学稍有不同，有时你想要透视投影，有时不想，具体取决于开发人员。如果想画立方体这种简单图形，直线就够了，但更复杂的图形，三角形更好，在3D图形学中，我们叫三角形"多边形"(Polygons)。

线框渲染虽然很酷，但3D图像需要填充，填充图形的经典算法叫[[扫描线渲染]] (Scanline Rendering) 于1967年诞生在犹他州大学

一种减轻锯齿的方法叫[[抗锯齿]](Antialiasing)，与其每个像素都涂成一样的颜色，可以判断多边形切过像素的程度，来调整颜色

在3D场景中，多边形到处都是，但只有一部分能看见，因为其它的被挡住了，这叫 遮挡

最直接的处理办法是用排序算法，从远到近排列，然后从远到近渲染，这叫[[画家算法]]，因为画家也是先画背景，然后再画更近的东西

还有一种方法叫[[深度缓冲]]，它和之前的算法做的事情一样，但方法不同.因为这个算法不用排序，所以速度更快，简而言之，[[Z-buffering]] 算法会记录，场景中每个像素和摄像机的距离，在内存里存一个数字矩阵。

1. 首先，每个像素的距离被初始化为"无限大"，然后 Z-buffering 从列表里第一个多边形开始处理，也就是A，它和扫描线算法逻辑相同，但不是给像素填充颜色。而是把多边形的距离和 Z-Buffer 里的距离进行对比，它总是记录更低的值，A距离20，20小于"无限大"，所以缓冲区记录20

![[Pasted image 20250919125333.jpg]]

2. 算完A之后算下一个，以此类推，因为没对多边形排序，所以后处理的多边形并不总会覆盖前面的。对于多边形C，缓冲区里只有一部分值会被多边形C的距离值覆盖，缓冲区完成后，会和"扫描线"算法的改进高级版配合使用

![[Pasted image 20250919125337.jpg]]

不仅可以勘测到线的交叉点，还可以知道某像素是否在最终场景中可见，如果不可见，扫描线算法会跳过那个部分。当两个多边形距离相同时，多边形会在内存中移来移去，访问顺序会不断变化，另外，计算浮点数有舍入误差，所以哪一个画在上面，往往是不可预测的，从而导致出现 Z-fighting 效果

3D游戏中有个优化叫[[背面剔除]]。你想想，三角形有两面，正面和背面，游戏角色的头部或地面，只能看到朝外的一面，所以为了节省处理时间，会忽略多边形背面。减了一半多边形面数，这很好，但有个bug是如果进入模型内部往外看，头部和地面会消失

---

灯光，也叫 明暗处理。因为3D场景中, 物体表面应该有明暗变化，我们回到之前的茶壶网格，用"扫描线"算法渲染所有多边形后，茶壶看起来像这样，没什么 3D 感。

![[Pasted image 20250919125657.jpg]]

我们来加点灯光，提高真实感。为了举例，我们从茶壶上挑3个不同位置的多边形，和之前的例子不同，这次要考虑这些多边形面对的方向。

![[Pasted image 20250919125703.jpg]]

它们不平行于屏幕，而是面对不同方向，他们面对的方向叫 "表面法线"，我们可以用一个垂直于表面的小箭头，来显示这个方向。

现在加个光源，每个多边形被照亮的程度不同，有的更亮，因为面对的角度，导致更多光线反射到观察者。举个例子，底部的多边形向下倾斜，远离光源，所以更暗一些，类似的，最右的多边形更背对光源，所以只有部分照亮。

![[Pasted image 20250919125709.jpg]]

最后是左上角的多边形，因为它面对的角度，意味着会把光线反射到我们这里，所以会显得更亮。

![[Pasted image 20250919125714.jpg]]

如果对每个多边形执行同样的步骤，看上去会更真实!这叫 平面着色，是最基本的照明算法。

![[Pasted image 20250919125719.jpg]]

不幸的是，这使多边形的边界非常明显，看起来不光滑，因此开发了更多算法，比如[[高洛德着色]]和[[冯氏着色]]。不只用一种颜色给整个多边形上色，而是以巧妙的方式改变颜色，得到更好的效果。

![[Pasted image 20250919125721.jpg]]

---
纹理在图形学中指外观，而不是手感，就像照明算法一样，纹理也有多种算法，来做各种花哨效果。最简单的是 [[纹理映射]]，为了理解纹理映射，回到单个多边形，用"扫描线算法"填充时，可以看看内存内的纹理图像，决定像素用什么颜色。

![[Pasted image 20250919125828.jpg]]

为了做到这点，需要把多边形坐标和纹理坐标对应起来，我们来看看"扫描线算法"要填充的第一个像素，纹理算法会查询纹理。从相应区域取平均颜色，并填充多边形，重复这个过程，就可以获得纹理，如果结合这集提到的所有技巧，会得到一个精美的小茶壶。

![[Pasted image 20250919125831.jpg]]

这个茶壶可以放进更大的场景里，场景由上百万个多边形组成，渲染这样的场景需要大量计算。但重要的是，再大的场景，过程都是一样的，一遍又一遍，处理所有多边形，扫描线填充, 抗锯齿, 光照, 纹理化。

然而，有几种方法可以加速渲染。首先，我们可以为这种特定运算，做专门的硬件来加快速度，让运算快如闪电。其次，我们可以把3D场景分解成多个小部分，然后并行渲染，而不是按顺序渲染。

CPU不是为此设计的，因此图形运算不快，所以，计算机工程师为图形做了专门的处理器，叫 GPU "图形处理单元"。

![[Pasted image 20250919125835.jpg]]

GPU 在显卡上，周围有专用的 RAM，所有网格和纹理都在里面，让 GPU 的多个核心可以高速访问。