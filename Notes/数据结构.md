# 1、数组（Array）

数组也叫列表（list）或向量（vector）

数组的值一个个连续存在内存里可以把多个值存在数组变量里

指定一个下标（index）以拿出数组中的某个值，大部分编程语言中的数组下标都从0开始，用方括号[]代表访问数组

假设编译器从[[内存地址]]1000开始保存数组，数组中的内容就像图中那样顺序保存在内存中。定义该数组变量为`j`，则`j[0]`会取内存地址1000的数据来获得第一个元素的值

![[{4D95045B-ACD8-4CEF-ABAF-43285BFCEB77}.png]]

用途广泛，几乎所有编程语言都自带了很多函数来处理数组

缺点：创建数组时就要固定大小，不能动态增加大小，并且数组在内存中是按[[顺序存储]]的，在中间插入一个值很困难。

# 2、字符串（String）

类似于数组，其实就是字母、数字、标点符号等构成的数组。我们在第4节中有讨论了计算机怎么存储字符的，通过ASCII或者[[Unicode]]编码，将字符转换为对应的二进制数。

写代码时，可以直接用引号括起来构建字符串`j="Hello World"`， 其在内存中的存储形式如下图。注意：字符串在内存中以二进制0结尾，表示字符串结尾，用来给别的函数指示什么时候字符串结束了。

![[Pasted image 20250909100440.jpg]]

# 3、矩阵（Matrix）

之前保存的都是[[一维数组]]，但是像电子表格或屏幕像素，都需要保存二维信息，所以这里就需要用到矩阵。

可以将矩阵看成是数组的数组，比如一个3x3矩阵， 相当于就是一个长度为3的数组，而这个数组中的每个元素又是一个长度为3的数组。矩阵保存在内存中的形式如下图所示，这里使用的是行优先存储，即优先将矩阵的每一行保存在内存的相邻位置，当一行保存完后，再保存下一行。

![[Pasted image 20250909101150.jpg]]

![[Pasted image 20250909101153.jpg]]

不仅能构建[[二维矩阵]]，还可以构建任意维度的矩阵

# 4、结构体（Struct)

目前我们只将单个数字或字符存在数组或矩阵中，在数组中保存的都是相同类型的元素。如果我们想把几个有关系的变量存储在一起，并且这些变量都是不同类型的，我们就需要用到结构体。

如下图我们构建了一个account结构体，该结构体中包含两个变量，我们声明一个[[结构体变量]]j，就能通过点运算符获取和赋值结构体中的变量，将其作为一个整体。

![[Pasted image 20250909101347.jpg]]

我们甚至可以做一个数组，里面放很多结构体，这些数组在内存里会自动打包在一起。我们可以看到，内存中会优先将一个结构体的所有变量放在相邻位置，再依次排列数组中的其他结构体。

![[Pasted image 20250909101356.jpg]]

# 5、指针（Pointer）

一种特殊变量，指向一个内存地址

# 6、节点（Struct）

用此可做成链表

灵活性是通过每个节点指向下一个节点实现的

# 7、链表（Linked List）

数组的缺点在于创建时就要固定大小，不能动态增加大小，并且数组在内存中是按顺序存储的，在中间插入一个值很困难。但结构体可以创造更复杂的数据结构来消除这些限制。

我们首先创建一个结构体Node，其中包含一个变量`i`和指针`next`。 指针是一种特殊变量，直接指向内存地址，因此`next`中保存的是内存地址。通过Node我们可以构建出链表

![[Pasted image 20250909101536.jpg]]

链表是一种灵活数据结构，能保存多个节点。灵活性是通过每个节点指向下一个节点实现的。假设我们有三个保存在内存地址1000、1002、1008中的节点，这些节点在内存中不是连续的，可能是因为它们的创建时间不同，使得它们之间包含了其他数据。我们可以看到第一个节点的值为7并且指向地址1008，这个内存地址1008就代表下一节点所在的内存地址，由此我们可以定位到下一节点，值为112并且指向地址1002，所以又可以得到下一个保存在内存地址1002的节点。而最后一个节点中的指针指向内存地址1000，使得这个链表为循环链表。我们同样可以令最后一个节点的指针指向0，来表示链表尽头。

![[Pasted image 20250909101547.jpg]]

所以整个链表通过指针将分散在内存各个位置的节点连接了起来，我们通过修改指针就能很轻易地修改链表内的值并进行插入删除。并且链表大小可以通过增减节点来达到动态增减的效果。链表很容易进行重排序、两端缩减、分割、倒序等操作，但是相比于数组的随机存取，链表需要依次遍历才能根据索引获取/修改对应的值。

我们可以忽略链表中的指针，得到数组的抽象模型。

![[Pasted image 20250909101556.jpg]]

由于链表的灵活性，很多数据结构底层都采用链表实现，比如队列（Queue）和栈（Stack）。队列中的数据是先进先出的，而栈中的数据是先进后出的。

在链表单个指针的基础上，增加一个指针，可以得到[[二叉树]]结构，两个指针分别表示[[左子树]]和右子树。

![[Pasted image 20250909101613.jpg]]

如果节点之间是随意连接的，就会得到图结构。

# 8、队列（Queue）

先进先出（FIFO）

# 9、栈（Stack）

后进先出（LIFO），入栈（Push）出栈（Pop）

# 10、树（Tree）

节点改一下改成2个指针变为树

根节点（Root）、子节点（Children）

任何子节点的直属上层节点叫“母节点”（Parent node）

树结束的地方叫“叶节点”（leaf）

根到叶是单向的

![[Pasted image 20250909111700.png]]

## 10.1、二叉树

节点最多只可以有两个子节点

# 12、图（Graph data）

